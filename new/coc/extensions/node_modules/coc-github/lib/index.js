"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const request_1 = __importDefault(require("request"));
const child = __importStar(require("child_process"));
async function activate(context) {
    let config = coc_nvim_1.workspace.getConfiguration('coc.github');
    let enable = config.get('enable', true);
    if (!enable) {
        return;
    }
    let priority = config.get('priority', 99);
    let filetypes = config.get('filetypes', ['gitcommit']);
    let source = {
        name: 'github',
        enable: true,
        shortcut: "I",
        filetypes: filetypes,
        priority: priority,
        sourceType: 2,
        triggerCharacters: ['#'],
        doComplete: async function () {
            const issues = await getIssues();
            return {
                items: issues.map(i => {
                    return {
                        word: i.character,
                        abbr: `#${i.character} ${i.description}`,
                        filterText: i.character + i.description
                    };
                })
            };
        }
    };
    context.subscriptions.push(coc_nvim_1.sources.createSource(source));
}
exports.activate = activate;
async function getIssues() {
    let repoUrl = await getRepoUrl();
    let options = {
        url: repoUrl,
        headers: { 'User-Agent': 'request' }
    };
    return new Promise((resolve, reject) => {
        request_1.default(options, (err, res, body) => {
            if (!err && res.statusCode == 200) {
                let issues = getCandidates(body);
                resolve(issues);
            }
            else {
                reject([]);
            }
        });
    }).then(result => {
        return result;
    }).catch((err) => {
        return err;
    });
}
function getCandidates(body) {
    let info = JSON.parse(body);
    let candidates = [];
    for (let i = 0, len = info.length; i < len; i++) {
        let issue = {
            character: info[i].number.toString(),
            description: info[i].title
        };
        candidates.push(issue);
    }
    return candidates;
}
async function getRepoUrl() {
    let cmd = 'git remote get-url origin';
    return new Promise((resolve, reject) => {
        child.exec(cmd, (err, stdout, stderr) => {
            if (err) {
                reject(stderr);
            }
            else {
                let remote = stdout.split('\n')[0];
                let repoUrl = remote.replace(/\.git$/, '');
                // for uri like `git@github.com:username/reponame.git`
                if (repoUrl.startsWith('git')) {
                    let repo = repoUrl.slice(4);
                    let info = repo.split(':', 2);
                    repoUrl = `https://api.github.com/repos/${info[1]}/issues?state=all`;
                }
                resolve(repoUrl);
            }
        });
    });
}
